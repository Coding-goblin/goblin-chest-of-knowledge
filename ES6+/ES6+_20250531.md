# ES6 and React basics

* ve verzi 6 pÅ™ibylo spoustu novÃ½ch vÄ›cÃ­, od tÃ© doby je v podstatÄ› kaÅ¾dÃ½ rok novÃ¡ verze, ale 6. verze je milnÃ­k mezi starÃ½m a novÃ½m Javascriptem
* promÄ›nnÃ© pomocÃ­ `const` a `let` je tÅ™eba taky souÄÃ¡st verze 6
* nÄ›kterÃ© vÄ›ci tÅ™eba z verze roku 2023,2024 jeÅ¡tÄ› prohlÃ­Å¾eÄe neumÃ­
* transpilÃ¡tory - umoÅ¾ÅˆujÃ­ psÃ¡t modernÃ­ kÃ³d, pÅ™eloÅ¾Ã­ ho do starÃ© syntaxe, kterou podporujÃ­ vÅ¡echny i starÅ¡Ã­ prohlÃ­Å¾eÄe
* nebudeme vklÃ¡dat Javascript rovnou na web, ale nastavÃ­me si workflow, kde nÃ¡Å¡ kÃ³d bude jeÅ¡tÄ› zpracovÃ¡n nÄ›ÄÃ­m - nÄ›co jako kdyÅ¾ jsme dÄ›lali se SASS a compilovalo se to do CSS

* v materiÃ¡lech se pouÅ¾Ã­vÃ¡ Webpack a Babel, ale my budeme pouÅ¾Ã­vat nÄ›co jinÃ©ho
  * Webpack byl dlouho standard, dneska uÅ¾ je dost zastaralÃ½, mÃ¡me uÅ¾ dnes novÃ© a lepÅ¡Ã­ nÃ¡stroje

* pÅ™eskakujeme Advanced environment configuration a nastavÃ­me si prostÅ™edÃ­ jinak

* funkce vyÅ¡Å¡Ã­ho Å™Ã¡du = high order function
  * pÅ™ijÃ­mÃ¡ jako parametr jinou funkci
  * napÅ™Ã­klad `addEventListener`:
  ```javascript
  button.addEventListener('click', priKliknuti);//pokud mam fci v promenne
  button.addEventListener('click', function(){});//pokud mam pokud mam anonymni fci
  ```
  * nebo kdyÅ¾ chci Å™adit ÄÃ­sla v poli pomocÃ­ sort a musim tam vlozit navic radici fci:
  ```javascript
  const cisla = [10, 113, 19, 32, 5]; // tohle nejde seradit jen pomoci sort

  function mojeRadiciFunkce(a,b) {
      return a - b;
  // if (a < b) {
  //   return -1
  // } else if (a > b) {
  //   return +1
  // } else {
  //   return 0; // pokud jsou a a b stejnÃ©, vracÃ­me 0
  // }  
  }

  cisla.sort(mojeRadiciFunkce); 
  ```
* **ternÃ¡rnÃ­ operÃ¡tor**
  * zjednoduÅ¡enÃ½ zÃ¡pis podmÃ­nky:
  ```javascript
  podminka ? ano : ne

  a.jmeno < b.jmeno? -1 : 1

  // takze treba:
  function mojeRadiciFunkce(a,b) {
    return a.jmeno < b.jmeno? -1 : 1; // podminka ? ano : ne
  }
  ```
## Array methods

* klasicky majÃ­ pole metodu `forEach`, `sort`

* funkce `localeCompare` - aby se seÅ™adilo podle ÄeskÃ© abecedy
  * `a.localeCompare(b);` - vrÃ¡tÃ­ to 1 nebo -1
  * mÅ¯Å¾u tam pÅ™idat dle jakÃ© abecedy to mÃ¡ bÃ½t jako parametr:
  ```javascript
  function podleJmena (a,b) {
    return a.jmeno.localeCompare(b.jmeno, "cs"); // tady specifikuju, Å¾e mÃ¡ sortovat podle ÄeskÃ© abecedy, tohle u ÄeÅ¡tiny vezme v potaz i ÄÃ¡rky a hÃ¡Äky (napÅ™. Ä po c apod.)
  }
  // ----------------------//

  console.table(zvirata); // vytiskne do konzole objekty zvirat, ale v tabulce
  ```

* nÄ›kterÃ© metody pÅ™Ã­mo mÄ›nÃ­ to pole, nÄ›kterÃ© ho nechajÃ­ jak je, vrÃ¡tÃ­ nÃ¡m ho novÃ© s aplikovanou to metodou, to pÅ¯vodnÃ­ nechajÃ­ bÃ½t

* `toSorted`
  * tahle metoda nemÄ›nÃ­ to pÅ¯vodnÃ­ pole, ale vytvoÅ™Ã­ novÃ© pole, kterÃ© je seÅ™azenÃ©:
  ```javascript
  const zvirata = [
  { jmeno: 'Kvakal ğŸ¸', vek: 1, vaha: 0.4 },
  { jmeno: 'Chloupek ğŸ˜¸', vek: 3, vaha: 2.7 },
  { jmeno: 'Hafik ğŸ¶', vek: 6, vaha: 13 },
  { jmeno: 'Kvikal ğŸ·', vek: 4, vaha: 37 },
  { jmeno: 'Kralicek ğŸ°', vek: 2, vaha: 1.5 },
  ];

  function podleJmena (a,b) {
    return a.jmeno.localeCompare(b.jmeno, "cs");
  }

  const serazenaZvirata = zvirata.toSorted( podleJmena );

  console.table(serazenaZvirata); // tohle vytiskne serazena zvirata
    ```


* mÅ¯Å¾u zadat i tÅ™i parametry - poloÅ¾ku, index, celÃ© pole:
  ```javascript
  function vypisJmeno(item, index, array) { // tyhle tri parametry maji dane poradi, takze javascript bude vedet, co chci, nezavisle na lokalni promenne, kterou jim priradim
    console.log(index, item.jmeno, array);
  } 
  ```


* `filter`
  * kdyÅ¾ chci z pole (array) vyfiltrovat jen nÄ›kterÃ© poloÅ¾ky podle nÄ›jakÃ©ho kritÃ©ria
  * kritÃ©rium je funkce (callback function), kterou tam zadÃ¡m jako parametr - napÅ™Ã­klad:

  ```javascript
  function jenLehkaZvirata(prvek) {
  if (prvek.vaha < 10) { // muzu nahradit nasledujicne
    return true
   } else {
    return false
  }
  return prvek.vaha < 10; // to v sobe obsahuje vsechno to je nad timhle
  } 

  const lehkaZvirata = zvirata.filter( jenLehkaZvirata ) // jenLehkaZvirata je callback function
  console.log(lehkaZvirata);
  ```
* `callback function` = A callback is a function that we pass as an argument to another function, and it's called at a later time or when something is finished.

* `map`
  * takÃ© metoda, kterÃ¡ nemÄ›nÃ­ pÅ¯vodnÃ­ pole, ale vrÃ¡tÃ­ nÃ¡m novÃ© pole
  * jeden po druhÃ©m vezme prvek, poÅ¡le ho do urÄenÃ© funkce, a novÃ¡ hodnota nahradÃ­ ten prvek v novÃ©m poli
  * chci novÃ© pole, kterÃ© bude mÃ­t stejnÃ½ poÄet prvkÅ¯, ale na stejnÃ© pozici kaÅ¾dÃ©ho prvku bude ten prvek zmÄ›nÄ›nÃ½:

  ```javascript
  const cisla = [10, 113, 19, 32, 5, 42];

  function vypocet(a) {
    return a * 2;
  }

  const dvojnasobky = cisla.map( vypocet )// puvodni pole "premapuju" na nove

  console.log(cisla);
  console.log(dvojnasobky);
  ```

  * nebo chci tÅ™eba transformovat data z prvku do textovÃ©ho Å™etÄ›zce:
  ```javascript
  function transformace(prvek) {
  return "MazlÃ­Äek " + prvek.jmeno + " vÃ¡Å¾Ã­ " + prvek.vaha + "kg a je starÃ½ " + prvek.vek + " rokÅ¯."
  }

  const novaZvirata = zvirata.map(transformace); // tohle vezme objekty zvirata a premapuje je tak, ze ve stejnem poradi tam bude kazdy prvek prepsany do vety viz vyse

  console.log(novaZvirata);
  ```
  * ta transformace pomocÃ­ pÅ™emapovÃ¡nÃ­ mÅ¯Å¾e bÃ½t ÃºplnÄ› cokoliv, napÅ™.:
  ```javascript
  function zjednodussit(prvek) { // treba chci jednotlive prvky zbavit nekterych vlastnosti, nebo jim nejake navic pridat
    return {
      name: prvek.jmeno,
      weight: prvek.vaha / 0.45, // prevedu vahu treba na jinou jednotku takhle
    }
  }

  const novaZvirata = zvirata.map(zjednodusit);
  console.table(novaZvirata);
  ```
* funkce `new Date().getFullYear();` mi najde aktuÃ¡lnÃ­ datum a z nÄ›j vypÃ­Å¡e rok

* `string literal` nebo `template string`
  * backtick **``**
    * mezi tÃ­mhle mÅ¯Å¾e bÃ½t text (string) klidnÄ› rozdÄ›lenÃ½ na nÄ›kolik Å™Ã¡dkÅ¯, mÅ¯Å¾u uvnitÅ™ toho zalamovat Å™Ã¡dky
    * vÅ¡echno, co je v nich, se interpretuje - vÄetnÄ› odsazenÃ­
    * mÅ¯Å¾u pÅ™Ã­mo do toho vloÅ¾it vÄ›ci v interpolaÄnÃ­ch symbolech `${}`, nemusÃ­m psÃ¡t `+`
    * nemusÃ­m poÅ™Ã¡d psÃ¡t uvozovky k textovÃ½m Å™etÄ›zcÅ¯m, je to jednoduÅ¡Å¡Ã­:

  ```javascript
  li.innerHTML = `<strong>${product.name}</strong><span>, ${product.price} - ${product.condition}</span>`; // vytvarim odrazky, ve kterych budou vyfiltrovana data z filteredProducts

  const text = `Ahoj. Ja jsem ${jmeno} a je mi ${vek} let.` // tady bych jinak musel psat uvozovky a +
  ```

  ```javascript
  function newProducts (product) {
    if (product.category === "car" && product.condition === "new" && product.price <= 45000)
    return product; // tohle je delÅ¡Ã­ forma, zkrÃ¡cenÄ› to mÅ¯Å¾e bÃ½t takhle:
    // return product.category === "car" && product.condition === "new" && product.price <= 45000; - tohle uz v sobe obsahuje tu podminku

  }

  const filteredProducts = products.filter(newProducts);

  const allProductsEl = document.querySelector("#all-products");// ziskam DOM elements
  const filteredProductsEl = document.querySelector("#filtered-products"); // ziskam DOM elements

  products.forEach( function (product) {

    const li = document.createElement("li");
    li.innerHTML = `<strong>${product.name}</strong><span>, ${product.price} - ${product.condition}</span>`;

    allProductsEl.appendChild(li);
  });

  filteredProducts.forEach( function (product) {

    const li = document.createElement("li");
    li.innerHTML = `<strong>${product.name}</strong><span>, ${product.price} - ${product.condition}</span>`; // vytvarim odrazky, ve kterych budou vyfiltrovana data z filteredProducts

    filteredProductsEl.appendChild(li); // skorapka, do ktere pak prijdou data seshora
  });
  ```
  * `filteredProductsEl` is like an empty gift box (`<div id="filtered-products"></div>` in your HTML)
  * `filteredProducts` is your carefully selected gift items (the filtered array)
  * Each `li` is like a gift-wrapped package containing one item from your selection


* jak pÅ™idat HTML obsah, aniÅ¾ bychom nÄ›jak ovlivnili to, co uÅ¾ tam je - napÅ™Ã­klad eventListeners nastavenÃ© na nÄ›Äem apod.:

  ```javascript
  const obsah = document.querySelector(".obsah"); // nasel jsem si misto, kam budu chtit pak novy element pripojit

  const odstavec = document.createElement("p"); // ted existuje element nÄ›kde v pamÄ›ti a mÅ¯Å¾u si na nÄ›m nastavit a pÅ™ipravit vÄ›ci, aniÅ¾ bych tÃ­m nÄ›jak ovlivÅˆoval ostatnÃ­ uÅ¾ existujÃ­cÃ­ elementy, je to o fous lepÅ¡Ã­ neÅ¾ pouÅ¾Ã­vat hned innerHTML

  odstavec.innerHTML = `Ahoj. Ja jsem <strong>Alena</strong> a je mi <em>27</em> let.` // pripravim tomu obsah
  odstavec.classList.add("text-yellow"); // nastavim tomu tridu

  obsah.appendChild(odstavec); // ted ten element muzu pripojit do DOM struktury k ostatnim elementum, aniz bych je nejak ovlivnil
  ```

## Arrow functions

* od verze ES6 je to novÃ½ zpÅ¯sob, jak zapisovat funkce
* nÄ›kdy se tomu taky Å™Ã­kÃ¡ "lambda vÃ½razy"

  ```javascript
  function fn1 () { // zakladni zapis funkce
    return 1;
  }

  const fn2 = function () { // funkce zapsana jako hodnota promenne
    return 2;
  }

  const fn3 = (a,b) => { // funkce zapsana jako arrow function v promenne
    return 3 * a * b;
  }

  () => {} // anonymni funkce zapsana jako arrow function
  ```
* `=>` tomuhle znamÃ©nku se Å™Ã­kÃ¡ "fat arrow"

* pokud mÃ¡ funkce prÃ¡vÄ› jeden parametr, tak mÅ¯Å¾u odstranit kulatÃ© zÃ¡vorky:
  ```javascript
  const dvojnasobek1 = (a) => { return 2 * a }; // tahle funkce ma prave jeden parametr

  const dvojnasobek2 = a => { return 2 * a }; // tohle je to stejne, ale muzu to psat bez kulatych zavorek okolo parametru
  ```
  * pozor: pokud nemÃ¡ funkce Å¾Ã¡dnÃ½ parametr, zÃ¡vorky tam bÃ½t MUSÃ, a to samÃ© platÃ­, pokud je tam vÃ­ce neÅ¾ jeden parametr

* pokud jedinÃ©, co ta funkce obsahuje, je `return` a nÄ›jakÃ¡ hodnota, kterou to vracÃ­, tak mÅ¯Å¾u smazat i ty sloÅ¾enÃ© zÃ¡vorky a `return`:
  ```javascript
  const dvojnasobek3 = a => 2 * a ;
  ```
  * kdyby tam toho bylo vÃ­c, tÅ™eba nÄ›jakÃ© dalÅ¡Ã­ vÃ½poÄty a podmÃ­nky, tak to takhle napsat nemÅ¯Å¾u

* tohle se hodÃ­ napÅ™Ã­klad u tÄ›ch funkcÃ­ pole (array functions):
  ```javascript
  const cisla = [13, 7, 38, 51, 42, 199, 5];

  const malaCisla = cisla.filter( (cislo) => { return cislo < 50 }) // chci filtrovat cisla, co jsou mensi nez 50

  const malaCisla = cisla.filter( cislo => cislo < 50 ) // muzu to takhle zkratit
  console.log(malaCisla);

  const serazenaCisla = cisla.toSorted( (a, b) => {return a - b} ) // tady mam dva parametry, takze nemuzu smazat kulate zavorky
  console.log(serazenaCisla);

  const serazenaCisla2 = cisla.toSorted( (a, b) => a - b )// ale je tam jen slovo return a jednoducha operace, takze muzu smazat return i slozene zavorky
  console.log(serazenaCisla);

  const dvojnasobnaCisla = cisla.map( (cislo) => { return cislo * 2} );
  console.log(dvojnasobnaCisla);

  const dvojnasobnaCisla = cisla.map( cislo => cislo * 2 ); // tady to zase muzu zkratit, protoze byl jen jeden parametr a jednoducha operace za return
  console.log(dvojnasobnaCisla);
  ```
* i kdyÅ¾ mÃ¡ arrow function jen jeden parametr a mohl bych tÃ­m pÃ¡dem smazat kulatÃ© zÃ¡vorky kolem nÄ›j, tak se tam dost Äasto nechÃ¡vajÃ­, aby bylo na prvnÃ­ pohled vidÄ›t, Å¾e se jednÃ¡ o funkci

* v javascriptu jde nastavit, aby parametry funkce mÄ›ly nÄ›jakou vÃ½chozÃ­ hodnotu, takÅ¾e pokud ji nÄ›kdo nezmÄ›nÃ­ a jen zavolÃ¡ tu funkci, aplikuje se tam ta hodnota, kterou jsme nastavili jako vÃ½chozÃ­
  ```javascript
  function funkce1 (a = 999) { // tady to se tam dosadi ve chvili, kdybych ja nebo nekdo funkci zavolal a nedosadil tam zadny parametr - jako treba funkce1();
    console.log(a);
  }
  funkce1(5); // tohle dosadi 5
  funkce1(); // tohle dosadi 999

  function kostka (hrac, pocetStran = 6) { // pokud se nezada nic jineho, tak bude pocet stran 6, povinnÃ½ parametr musi byt v kulate zavorce pred tim vychozim (volitelnÃ½m)
  const hod = Math.floor( Math.random() * pocetStran + 1) // tohle simuluje hozeni kostkou libovolneho poctu stran
    
  return `HrÃ¡Ä ${hrac} hodil ${hod} na kostce s ${pocetStran} stranami.`
  }

  console.log (kostka("Jenda",12));
  console.log (kostka("Alena"));
  ```
* **tady u toho vysvetleni se do toho ale zamotal, neni mi to jasne**

* `this` mÄ›nÃ­ obsah v zÃ¡vislosti na kontextu, ale uvnitÅ™ `arrow function` zÅ¯stÃ¡vÃ¡ hodnota `this` stejnÃ¡, jakou mÄ›lo, neÅ¾ se ta `arrow function` spustila:

  ```javascript
  const tlacitko = document.querySelector("#tlacitko");
  tlacitko.addEventListener("click", function() {
    console.log("click");
    console.log(this); // tohle this obsahuje ten prvek, ktery tu udalost vyvolal
  })

  // pak to prepisu na tu arrow function

  const tlacitko2 = document.querySelector("#tlacitko");
  tlacitko.addEventListener("click", () => {
    console.log("click");
    console.log(this); // tohle this obsahuje to, co obsahovalo predtim, nez se arrow funkce spustila - v tomto pripade je to undefined
  })
  ```
* z tohohle dÅ¯vodu nemÅ¯Å¾u arrow functions pouÅ¾Ã­vat u Object Constructor Functions (??), protoÅ¾e to nedokÃ¡Å¾e na to this odkÃ¡zat a vytvoÅ™it dle Å¡ablony objekt (???)

* Arrow functions nemajÃ­ vlastnÃ­ `this` - mÃ­sto toho pÅ™ebÃ­rajÃ­ `this` z okolnÃ­ho (lexikÃ¡lnÃ­ho) kontextu, ve kterÃ©m byly vytvoÅ™eny

* ProblÃ©m s constructor functions:
  * Constructor functions (funkce pouÅ¾Ã­vanÃ© s new) potÅ™ebujÃ­ mÃ­t vlastnÃ­ `this`, kterÃ© bude odkazovat na novÄ› vytvÃ¡Å™enou instanci. Arrow functions to nemohou udÄ›lat, protoÅ¾e nemajÃ­ vlastnÃ­ `this`

* takÅ¾e metody objektÅ¯ nemÅ¯Å¾eme vytvÃ¡Å™et pomocÃ­ arrow functions, stejnÄ› jako `eventListener`s a `object constructor functions`

* **tady u toho vysvetleni se do toho ale zamotal, neni mi to jasne**

* v pÅ™Ã­padÄ› fce console.log v ramci forEach mÅ¯Å¾u zkrÃ¡tit i takhle:

```javascript
const printArray = array => {
  array.forEach((element) => {
    console.log(element);
  });
};

const printArray = array => {
  array.forEach(console.log); // tohle je to same ale nejvic zkracene
};

```