# Parameters passing

* obÄas potÅ™ebujeme z udÃ¡losti zÃ­skat Ãºdaje o tÃ© udÃ¡losti samotnÃ©
* mÅ¯Å¾u pouÅ¾Ã­t vlastnosti `event object`u, coÅ¾ je parametr, kterÃ½ React automaticky dosazuje do funkce jakÃ©hokoli `eventHandler`u
* mÅ¯Å¾u ho zavolat jako parametr vÃ½slovnÄ›, a pak dÃ¡l pracovat s jeho vlastnostmi:

  ```javascript
  export function Events() {
    
    const handleClick = (event) => {
      console.log("Kliknuto");
      console.log(event.target); // tohle mi do konzole vytiskne, kterÃ½ prvek ten event vyvolal - to se mi bude hodit pozdÄ›ji, aÅ¾ budu pracovat s formulÃ¡Å™i
    }
    
    
    return(
      <>
        <button onClick={handleClick}>Klikni na me</button>
        <button onClick={(event) => {console.log(event.target)}}>Druhe tlacitko</button> // pokud pisu funkci anonymne rovnou sem, tak event dosazuju sem viz onClick Druheho tlacitka
      </>
    )
  }
  ```

* `onClick` oÄekÃ¡vÃ¡ funkci, ne vÃ½sledek zavolÃ¡nÃ­ funkce:

  ```javascript
  export function Events() {
    
    const handleClick = (event) => {
      console.log("Kliknuto");
      console.log(event.target); // tohle mi do konzole vytiskne, kterÃ½ prvek ten event vyvolal - to se mi bude hodit pozdÄ›ji, aÅ¾ budu pracovat s formulÃ¡Å™i
    }
    
    
    return(
      <>
        <button onClick={handleClick}>Klikni na me</button>
        <button onClick={(event) => {console.log(event.target)}}>Druhe tlacitko</button> // pokud pisu funkci anonymne rovnou sem, tak event dosazuju sem viz onClick Druheho tlacitka

        <button onClick={rocniObdobi(1)}>Jaro</button> // tohle nebude fungovat
        <button onClick={() => {rocniObdobi(1)}}>Jaro</button> // tohle bude fungovat
      </>
    )
  }
  ```

* pokud to napÃ­Å¡u takhle: `<button onClick={rocniObdobi(1)}>Jaro</button>`, tak volÃ¡m funkci `rocniObdobi` okamÅ¾itÄ›, jakmile se naÄte komponenta - ne ve chvÃ­li, kdy uÅ¾ivatel klikne na tlaÄÃ­tko => vÃ½sledek tÃ© funkce bude pravdÄ›podobnÄ› `undefined`, to se dosadÃ­ do `onClick` a React to zmate nebo to ÃºplnÄ› vyignoruje

* sprÃ¡vnÄ› musÃ­m tu funkci v onClick zaobalit do dalÅ¡Ã­ anonymnÃ­ funkce, ÄÃ­mÅ¾ Å™eknu, Å¾e se ta funkce mÃ¡ spustit pozdÄ›ji, aÅ¾ se na tlaÄÃ­tko klikne:

  `<button onClick={() => {rocniObdobi(1)}}>Jaro</button>`

| Code                         | Analogy                                                        | Result   |
| ---------------------------- | -------------------------------------------------------------- | -------- |
| `onClick={someFunc}`         | Give robot a button label: â€œRun `someFunc` when clickedâ€       | âœ… Works  |
| `onClick={someFunc()}`       | Robot runs `someFunc` immediately. Button is dead.             | âŒ Broken |
| `onClick={() => someFunc()}` | Wrap the call in a mini robot instruction sheet. Run on click. | âœ… Works  |

* kdyÅ¾ nechci, aby se mi po kliknutÃ­ na odkaz posunula strÃ¡nka nahoru, tak musÃ­m pouÅ¾Ã­t `preventDefault()`

  ```javascript
  export function MobileMenu(){

    const [isOpen,setIsOpen] = useState(false)

    const handleMenu = (event, open) => {
      event.preventDefault() // tohle zabrani posunuti nahoru
      setIsOpen(open)
    }

    return(
      <>
        <section className="mobile">
          <header className="mobile-menu">
            <a onClick={(event) => {handleMenu(event,true)}} // sem musim dat event parametr
            href="#" 
            className="open-menu"></a>
            <nav className={isOpen ? '' : 'hide'}>
              <ul>
                <li><a href="#">About us</a></li>
                <li><a href="#">Team</a></li>
                <li><a href="#">Products</a></li>
                <li><a href="#">Contact</a></li>
              </ul>
              <a onClick={(event) => {handleMenu(event,false)}}
                 href="#"
                 className="close-menu">Close menu</a>
            </nav>
          </header>
        </section>
      </>
    )
  }
  ```
  * kdyÅ¾ se dÃ¡vajÃ­ tÅ™eba odkazy mÃ­sto tlaÄÃ­tka, tak defaultnÄ› po kliknutÃ­ na to se strÃ¡nka posune na zaÄÃ¡tek
  * mÅ¯Å¾e bÃ½t odkaz s `href=#`, coÅ¾ nikam nevede, ale mÅ¯Å¾e to nÄ›co dÄ›lat, viz nahoÅ™e


## Komunikace mezi komponenty

* mezi rodiÄovskou komponentou a potomkovskou komponentou - od rodiÄe smÄ›rem do potomka: data se pÅ™edajÃ­ pÅ™es `props`:

  ```javascript
  import {ButtonToClick} from "./ButtonToClick" // importuju potomka

  // tohle je rodiÄ
  export function ButtonCounter () {

    return (
      <div style={{
        border: "5px solid dodgerblue",
        padding: 20,
      }}>

        <h1>99</h1>

        <ButtonToClick text="PrvnÃ­ tlaÄÃ­tko"/> // z ButtonCounter (rodiÄ) do ButtonToClick (potomek) pÅ™edÃ¡vÃ¡m data pÅ™es props
        <ButtonToClick text="DruhÃ½ ÄudlÃ­k ğŸ·"/>
      </div>
    )
  }

  // tady mam potomka:
    export function ButtonToClick ({text}){
    return(
      <div style={{
        border: "5px solid red",
        margin: 10,
        padding: 20,
        }}>
           
        <button>{text}</button>
      </div>
    )
  }
  ```

* ale mÅ¯Å¾u potÅ™ebovat i pÅ™edat data naopak z potomka do rodiÄe, toho mÅ¯Å¾u docÃ­lit tak, Å¾e tam pÅ™edÃ¡m promÄ›nnou, kterÃ¡ bude funkce, jako `prop`

  * vÄ›tÅ¡inou se ta funkce jmenuje podobnÄ› jako udÃ¡lost, na kterou mÃ¡ reagovat

* vytvoÅ™Ã­me funkci v rodiÄi, tu pÅ™edÃ¡me jako promÄ›nnou do potomka, a kdyÅ¾ potomek bude chtÃ­t komunikovat, tak tuhle funkci zavolÃ¡ a ovlivnÃ­ tÃ­m rodiÄe

  ```javascript
  export function ButtonCounter () {

    const [count,setCount] = useState(0)

    const handleButtonClick = () => { // tady mÃ¡m tu funkci
      setCount(prev => prev + 1)
    }

    return (
      <div style={{
        border: "5px solid dodgerblue",
        padding: 20,
      }}>

        <h1>{count}</h1> // tady se mi bude zvysovat cislo, i kdyz spoustim funkci v potomkovi a ne v rodiÄi

        <ButtonToClick text="PrvnÃ­ tlaÄÃ­tko" onButtonClick = {handleButtonClick} /> // tady mam props, ktery je funkce
        <ButtonToClick text="DruhÃ½ ÄudlÃ­k ğŸ·" onButtonClick = {handleButtonClick}/>

      </div>
    )
  }

  // v potomkovi to pouziju jako funkci

  export function ButtonToClick ({text, onButtonClick}){ // to onButtonClick je stejna funkce jako handleButtonClick, on to jen takhle nazval v tehle komponente
    return(
      <div style={{
        border: "5px solid red",
        margin: 10,
        padding: 20,
        }}>
           
        <button onClick={() => {onButtonClick()}}> // tady tu funkci pouzivam v reakci na kliknuti na tlacitko v potomkovi
          {text}</button>
      </div>
    )
  }
  ```
* nejsloÅ¾itÄ›jÅ¡Ã­ zpÅ¯sob komunikace by byl, kdybychom potÅ™ebovali pÅ™edat informace mezi dvÄ›ma komponenty - sourozenci (napÅ™Ã­klad tÄ›mi dvÄ›ma `ButtonToClick`)

  * v tom pÅ™Ã­padÄ› by nejdÅ™Ã­v pÅ™edal informaci jeden potomek rodiÄi, a pak ten rodiÄ by ji pÅ™edal druhÃ©mu potomkovi

## ZpracovÃ¡nÃ­ formulÃ¡Å™Å¯

* abychom mohli pracovat s hodnotami zadanÃ½mi do formulÃ¡Å™Å¯, tak je potÅ™ebujeme dostat do nÄ›jakÃ½ch promÄ›nnÃ½ch - a to chceme, aby se dÄ›lo automaticky (?)

* tu promÄ›nnou chceme mÃ­t uloÅ¾enou jako stav (`useState`), takÅ¾e ji pak mÅ¯Å¾eme nÄ›kam vypisovat a bude se mÄ›nit automaticky podle toho, co se zadalo do formulÃ¡Å™e

* `one-way data binding` = kdyÅ¾ nÄ›co zadÃ¡m do `useState` a propÃ­Å¡e se mi to do pole formulÃ¡Å™e(`<input>`)

* potÅ™ebuju `two-way binding`, tedy aby ta data mohla chodit obousmÄ›rnÄ›

  * mÅ¯Å¾u na tom inputu reagovat na udÃ¡lost `onChange`, a v anonymnÃ­ funkci, kterou budu na udÃ¡lost reagovat, potÅ™ebuju zjistit, co tam uÅ¾ivatel zadal

  * udÄ›lÃ¡m to tak, Å¾e vÃ½chozÃ­ hodnotu z `useState` promÃ­tnu do pole a pak pÅ™es `event` object zmÄ›nÃ­m hodnotu `target`u pÅ™es useState funkci, coÅ¾ zmÄ›nÃ­ hodnotu promÄ›nnÃ© `useState` a promÃ­tne se mi to do pole (je to kruhovÃ¡ reakce)
  
    * mÅ¯Å¾u nastavit samozÅ™ejmÄ› `useState` na prÃ¡zdnÃ© uvozovky:

        `const [name,setName] = useState("")`
        
        takÅ¾e bude na zaÄÃ¡tku to mÃ­sto prÃ¡zdnÃ© a pak se tam jen vypÃ­Å¡e to stejnÃ©, co se zadalo do `input` pole

  ```javascript
  import {useState} from "react"

  export function Hello () {

    const [name,setName] = useState("Alena")

    return(
      <>
        <h1>JmÃ©no: {name}</h1>
        <input 
          type="text" 
          value={name}
          onChange={(event) => {setName(event.target.value)}}
        />
      </>
    )
  }
  ```
* tohle budu v nÄ›jakÃ© podobÄ› dÄ›lat pÅ™i prÃ¡ci s formulÃ¡Å™i poÅ™Ã¡d

* u `<input type="checkbox">` budou ty hodnoty `useState` true/false, a vÄ›tÅ¡inou defaultnÄ› nastavÃ­m na false (nezaÅ¡krtnuto)
* u `checkbox`u to nenÃ­ hodnota `value`, ale `checked`

  ```javascript
  <h2>Souhlas: {consent ? "ano" : "ne"} </h2>
  <input 
        type="checkbox"
        checked={consent}
        onChange={(event) => {setConsent(event.target.checked)}}
  />
  ```

* ve formulÃ¡Å™i bychom nemÄ›li reagovat na udÃ¡lost `onClick`, ale `onSubmit`

* formulÃ¡Å™ovÃ¡ pole by mÄ›la bÃ½t zabalena do tagu `<form>`

* ke tlaÄÃ­tku odeslÃ¡nÃ­ mÅ¯Å¾u pÅ™ipsat `type="submit"`, ale kaÅ¾dÃ© tlaÄÃ­tko uvnitÅ™ formulÃ¡Å™e (kÃ³du uvnitÅ™ `<form>`), zpÅ¯sobÃ­ odeslÃ¡nÃ­ formulÃ¡Å™e

* `onSubmit` pÅ™idÃ¡m k poÄÃ¡teÄnÃ­mu tagu `<form>`

* odeslÃ¡nÃ­ formulÃ¡Å™e mÃ¡ v prohlÃ­Å¾eÄi vÃ½chozÃ­ akci, stejnÄ› jako tÅ™eba kliknutÃ­ na odkaz
  * je to refresh strÃ¡nky
  * takÅ¾e budu nastavovat `preventDefault` - vÄ›tÅ¡inou chceme s tÃ­m formulÃ¡Å™em dÄ›lat nÄ›co sami, nechceme defaultnÃ­ akci (v Reactu vÄ›tÅ¡inou tu defaultnÃ­ reakci nechceme)

  ```javascript
    const handleSubmit = (event) => {
      event.preventDefault()
      console.log(name)
      console.log(city)
      console.log(comment)
      console.log(consent)
      console.log("---")
    }
  ```

* ve chvÃ­li, kdy by tÄ›ch polÃ­Äek ve formulÃ¡Å™i bylo hodnÄ›, tak uÅ¾ je lepÅ¡Ã­ to nastavit jako jeden `useState`, kterÃ½ bude obsahovat objekt, jehoÅ¾ vlastnosti budou ty jednotlivÃ© poloÅ¾ky formulÃ¡Å™e

* v Javascriptu je slovo `for` vyhrazenÃ© na jinÃ© vÄ›ci, takÅ¾e kdyÅ¾ urÄuju, k Äemu patÅ™Ã­ `<label>`, tak nepÃ­Å¡u `for=` , ale `htmlFor=`:

  ```javascript
  return(
      <form>
        <label htmlFor="username"></label>
        <input id="username" type="text" />
      </form>
  )
  ```

* pÅ™edtÃ­m, neÅ¾ data z formulÃ¡Å™e odeÅ¡lu, mÄ›l bych formulÃ¡Å™ `validovat` - ovÄ›Å™it, zda zadanÃ© hodnoty splÅˆujÃ­ urÄenÃ© podmÃ­nky

  * napÅ™Ã­klad by nemÄ›lo jÃ­t odeslat prÃ¡zdnÃ½ formulÃ¡Å™
  * do polÃ­Äka, kam se majÃ­ zadat ÄÃ­sla, musÃ­ bÃ½t zadanÃ¡ jen ÄÃ­sla atp.
  * nebo tÅ™eba dÃ©lka zadanÃ½ch hodnot minimÃ¡lnÄ› 2 znaky apod.

* chci, aby se mi pÅ™Ã­padnÃ¡ chyba ve formulÃ¡Å™i nÄ›kde vypsala a NE pÅ™es alert, kterÃ½ je dost naprd pro uÅ¾ivatele

  * udÄ›lÃ¡m pÅ™es `useState`

  * ideÃ¡lnÄ› se ty hlÃ¡Å¡ky budou pÅ™idÃ¡vat do prÃ¡zdnÃ©ho pole v `useState` a pak se vÅ¡echny vypÃ­Å¡ou:

  ```javascript
  import {useState} from "react"

  import FakeAPI from "./data/fakeAPI"

  export function Form() {
    const [username, setUsername] = useState("")
    const [password, setPassword] = useState("")

    const [errorMessages, setErrorMessages] = useState([])

    const handleSubmit = (event) => {
      event.preventDefault()

      const errors = [] // na zacatku neni zadny error


      if (username.length <= 2) {
        errors.push("UÅ¾ivatelskÃ© jmÃ©no musÃ­ bÃ½t delÅ¡Ã­ neÅ¾ 2 znaky")
        // pokud bude username moc kratke, tak se prida hlaska do pole
      }

      if (password.length <= 4) {
        errors.push("Heslo musÃ­ bÃ½t delÅ¡Ã­ neÅ¾ 4 znaky")
        // pokud bude username moc kratke, tak se prida hlaska do pole
      }
      
      setErrorMessages(errors) // do stavu dodam vsechny error hlasky, ktere se udelaly

      // pokud delka pole errors neni nulova, tak chci z te funkce odejit a nepokracovat k loginu:

      if (errors.length > 0) {return}

      FakeAPI.login({
        username: username,
        password: password
      }).then(user => {
        console.log("JupÃ­, jsi pÅ™ihlÃ¡Å¡enÃ½")
        console.log(user)
        // in the user variable we have access to information about the user who has logged in
      }).catch(err => {
        // in the err variable we have access to information about the error
        console.log("Chyba pÅ™i pÅ™ihlÃ¡Å¡enÃ­")
        console.log(err)
      })
    }

    return(
      <form onSubmit ={handleSubmit}>

        <ul style={{color: "red"}}>
          {errorMessages.map((msg,index) => <li key={index}>{msg}</li>)}
        </ul>

        <div>
          <label htmlFor="username">PÅ™ihlaÅ¡ovacÃ­ jmÃ©no:</label>
          <input 
            id="username"
            type="text"
            value={username}
            onChange={ (event) => {setUsername(event.target.value) }}
          />
        </div>

        <div>
          <label htmlFor="password">Heslo:</label>
          <input 
            id="password"
            type="password"
            value={password}
            onChange={ (event) => {setPassword(event.target.value) }}
          />
        </div>

        <button type="submit">PÅ™ihlÃ¡sit se</button>

      </form>
    )
  }
  ```